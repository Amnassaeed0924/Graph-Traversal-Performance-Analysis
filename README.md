Comparative Analysis of Graph Traversal Algorithms (BFS vs DFS)
ğŸ“‹ Project OverviewThis project provides an empirical performance analysis of Breadth-First Search (BFS) and Depth-First Search (DFS). The study focuses on how different graph representationsâ€”Adjacency Matrix and Adjacency Listâ€”impact execution speed and memory consumption.The ProblemWhile BFS and DFS are theoretically well-understood, their practical performance varies wildly based on graph density and storage methods. This project quantifies these differences, specifically highlighting how Adjacency Lists can be over 100x more memory-efficient in sparse graph scenarios.
ğŸš€ Key ObjectivesImplementation: Developed iterative BFS and DFS algorithms in C++.Benchmarking: Measured execution time using clock() and memory via peak auxiliary storage.Comparison: Evaluated $O(V^2)$ vs. $O(V + E)$ space complexities in real-world simulations.Visualization: Recorded data across varying node sizes to observe scaling trends.
ğŸ“Š Comparison SummaryFeatureAdjacency MatrixAdjacency ListData Structure2D ArrayArray of Lists/VectorsSpace Complexity$O(V^2)$$O(V + E)$Memory EfficiencyLow (Static)High (Dynamic)Edge Lookup$O(1)$$O(degree(v))$Best Use CaseDense GraphsSparse Graphs / Large Networks
ğŸ› ï¸ MethodologyGraph Generation: Randomly generated connected graphs to ensure full traversal.Uniform Testing: The same graph structure is applied to both Matrix and List representations to ensure a fair "apples-to-apples" comparison.Memory Tracking: Instead of total RAM, we measure the Peak Auxiliary Space:DFS: Maximum Stack size during recursion/iteration.BFS: Maximum Queue size during traversal.Environment: * Language: C++IDE: Dev C++ / Online CompilerOS: Windows
ğŸ” Assumptions & ConstraintsConnectivity: All generated graphs are connected to prevent early termination of algorithms.Source Node: All traversals begin from the same initial vertex for consistency.Matrix Scanning: The algorithm assumes a full row scan ($O(V)$) to identify neighbors in the Matrix representation, reflecting standard implementation overhead.
ğŸ“ˆ Results HighlightsMemory: Adjacency Lists showed a massive advantage in memory scaling, especially as the number of nodes ($V$) increased while edges ($E$) remained relatively low.Execution Time: Adjacency Lists outperformed Matrices in neighbor discovery because they do not need to scan "empty" edges (zeros in the matrix).
ğŸ“‚ How to RunClone the repository:Bashgit clone https://github.com/YourUsername/RepositoryName.git
Open main.cpp in Dev C++ or any C++ compiler.Compile and run.Check the generated text files for performance logs and metrics.
