Graph Traversal Benchmark: Matrix vs. ListA performance analysis of BFS and DFS algorithms comparing Adjacency Matrix vs. Adjacency List representations in C++.ğŸš€ Key FindingAdjacency Lists are 100x more memory-efficient than Adjacency Matrices for sparse graphs, significantly reducing overhead in large-scale traversals.ğŸ“Œ Project OverviewGraph traversal is essential for networking, AI, and OS pathfinding. This project solves the problem of choosing the right data structure by measuring the real-world time and memory trade-offs of BFS and DFS.Objectives:Compare execution time using the clock() function.Measure memory usage by tracking peak Stack (DFS) and Queue (BFS) sizes.Analyze how performance scales as graph size increases.ğŸ“Š Comparison at a GlanceFeatureAdjacency MatrixAdjacency ListStorage2D Array ($V^2$)Array of Lists ($V+E$)Memory UsageHigh (Fixed)Low (Scalable)Edge LookupInstant ($O(1)$)Slower ($O(\text{degree})$)Best ForDense GraphsSparse GraphsğŸ› ï¸ Methodology & ConstraintsRandom Generation: Generates connected graphs to ensure complete traversal.Fair Testing: The same random graph is converted into both Matrix and List formats for an unbiased comparison.Traversal: Both BFS and DFS start from the same source node.Metrics: * Time: Measured via CPU clock cycles.Memory: Tracks the maximum auxiliary space (stack/queue) used during execution.ğŸ’» Tech StackLanguage: C++Tools: Dev C++, Online GDBOS: WindowsğŸ“‚ Repository Structuremain.cpp: The core implementation of BFS/DFS and graph generation.results/: Text files containing recorded execution times and memory metrics.
